# Задача python скрипта 
Скрипт решает обратную задачу: он определяет, каким должен быть параметр k, чтобы получить желаемый показатель RTP . Для этого он строит калибровочную таблицу зависимости k от RTP.

## Шаг 1: Моделирование ставки игрока (dist_X)
В основе модели лежит предположение о том, как распределены ставки игроков. Скрипт моделирует ставку (bet) как случайную величину из усечённого нормального распределения.

Таким образом, dist_X — это математическая модель, описывающая вероятность сделать ставку определённого размера.

## Шаг 2: Определение вероятности выигрыша (p_survive)
Вероятность выигрыша зависит как от размера ставки (bet), так и от калибровочного параметра k.

Эта вероятность определяется как: p_survive = 1 - ((bet - 1) / (X_MAX - 1))**(1/k)

Эта формула выводится из базовой модели выигрыша: multiplicator = 1 + (X_MAX - 1) * U^k, где U — случайная величина, равномерно распределённая на отрезке [0, 1].

Игрок выигрывает, если multiplicator > bet. Вероятность этого события и есть p_survive.

При большом k (например, k=50), U^k будет очень близко к нулю. multiplicator будет близок к 1, и вероятность выигрыша будет низкой. Это соответствует низкому RTP.
При маленьком k (например, k=0.01), U^k будет близко к 1. multiplicator будет большим, и вероятность выигрыша будет высокой. Это соответствует высокому RTP.
Таким образом, параметр k напрямую управляет "щедростью" игры.

## Шаг 3: Вычисление ожидаемого RTP (expected_rtp)
RTP — это отношение ожидаемого выигрыша к ожидаемой ставке: RTP = E[Выигрыш] / E[Ставка]

E[Ставка] — это просто среднее значение распределения dist_X, то есть dist_X.mean().

E[Выигрыш] вычисляется как математическое ожидание величины bet * p_survive по всем возможным значениям ставки. Математически это выражается через интеграл:

E[Выигрыш] = ∫[от X_MIN до X_MAX] bet * p_survive(bet, k) * pdf(bet) dbet

где pdf(bet) — это плотность вероятности для ставки bet (из dist_X.pdf(bet)).

Функция expected_rtp(k) вычисляет этот интеграл (с помощью scipy.integrate.quad) и делит его на среднюю ставку, получая теоретический RTP для заданного k.

## Шаг 4: Поиск k для целевого RTP (find_k)
Здесь решается обратная задача: у нас есть целевой rtp_target, и нам нужно найти такое k, при котором expected_rtp(k) == rtp_target.

Это эквивалентно поиску корня уравнения: f(k) = expected_rtp(k) - rtp_target = 0.

Для решения этой задачи используется метод деления отрезка пополам (scipy.optimize.bisect). Этот метод надёжен для монотонных функций (чем меньше k, тем выше RTP).

Метод ищет корень k на отрезке [K_MIN, K_MAX].
Если целевой RTP оказывается за пределами диапазона, который могут обеспечить k из этого отрезка, функция возвращает одно из граничных значений (K_MIN или K_MAX), что является логичной обработкой такой ситуации.
## Шаг 5: Построение и сохранение калибровочных данных
Последний шаг — это автоматизация процесса для целого ряда значений RTP.

Создаётся сетка значений RTP от 0.01 до 1.0 (np.linspace(0.01, 1.0, 200)).
В цикле для каждого значения rtp из этой сетки вызывается find_k, чтобы найти соответствующее значение k.
Полученные пары (rtps, ks) сохраняются в файл calibration.json.
Go-приложение может загрузить его и использовать для быстрой установки k под нужный RTP.

## Итог:

* Определяет вероятностную модель ставок.
* Формулирует зависимость выигрыша от параметра k.
* Вычисляет ожидаемый RTP через интегрирование.
* Решает обратную задачу (поиск k по RTP) с помощью численного метода.
* Генерирует готовую к использованию калибровочную таблицу.
